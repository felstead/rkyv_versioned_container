//! This crate provides functionality for supporting versioned serialization and deserialization of
//! `rkyv` Archives, allowing for backwards and (limited) forwards compatibility between different
//! versions of your code.  This is implemented through using the
//! `#[derive(VersionedArchiveContainer)]` macro as generated by the sister [rkyv_versioned_derive]
//! crate.
//!
//! # Usage
//! To provide backwards and forwards compatibility between structures formatted by `rkyv`, we
//! follow these steps:
//! - We should provide implementations of all "known" versions of an `rkyv` structure in our code
//!   (see `TestStructV1` and `TestStructV2` in the example below)
//! - We wrap these versions in an enum describing all of the different versions, and use the
//!   `#[derive(VersionedArchiveContainer)]` macro on that enum in addition to your usual
//!   `#[derive(Archive, Serialize, Deserialize)]` definitions for an `rkyv` type, see
//!   `TestVersionedContainer` in the example below.
//!
//! However, there are some important rules to abide by:
//! - **The layout/structure of the `rkyv` implementations MUST NOT CHANGE between versions of the
//!   code** - if you make changes, it is important to declare a new type and add it to our
//!   versioned container. This is because we will try to deserialize/access the data using the
//!   implementation in the current code, so if we serialize `TestStructV1` with one layout and then
//!   change it later, it may not be able to be read correctly.  Instead, try declaring
//!   `TestStructV2` and add it to our versioned container.
//! - **The versioned container's enum order MUST NOT CHANGE** - the IDs of each variant are based
//!   on their order, so it is important to keep this consistent and **only add new variants to the
//!   end of the struct**.
//!
//!
//! # Example
//! ```rust
//! use rkyv::{Archive, Serialize, Deserialize};
//! use rkyv::util::AlignedVec;
//! use rkyv::with::Inline;
//! use rkyv_versioned::*;
//!
//! #[derive(Debug, Archive, Serialize, Deserialize)]
//! struct TestStructV1 {
//!     pub a: u32,
//!     pub b: u32,
//!     pub c: String,
//! }
//!
//! #[derive(Debug, Archive, Serialize, Deserialize)]
//! struct TestStructV2 {
//!     pub a: u64,
//!     pub b: u64,
//!     pub c: u64,
//!     pub d: String,
//! }
//!
//! #[derive(Debug, Archive, Serialize, Deserialize, VersionedArchiveContainer)]
//! enum TestVersionedContainer<'a> {
//!     V1(#[rkyv(with=Inline)] &'a TestStructV1),
//!     V2(#[rkyv(with=Inline)] &'a TestStructV2),
//! }
//!
//! fn main() {
//!     // Serialize a v1 into a versioned container byte stream
//!     let v1 = TestStructV1 {
//!         a: 1,
//!         b: 2,
//!         c: "YEET".to_owned(),
//!     };
//!
//!     // Create our versioned container to store our v1 data
//!     let container = TestVersionedContainer::V1(&v1);
//!
//!     // This byte stream contains extra metadata allowing you to identify the type and version before
//!     // attempting to access it
//!     let tswv_container_bytes: AlignedVec = TestVersionedContainer::to_tagged_bytes(&container).unwrap();
//!
//!     // Imagine now that you're reading this byte stream from a file or network - it is _probably_ a
//!     // TestContainer::V1, but you can't be sure, it _could_ be a TestContainer::V2 (which would
//!     // be fine) or, if we're older version of the code against newer data, a TestContainer::V3.  Or
//!     // maybe it's not even a TestContainer at all. With the tagged container, we can validate
//!     // beforehand, or have logic to handle different structures or versions.
//!     let (type_id, version_id) =
//!         TestVersionedContainer::get_type_and_version_from_tagged_bytes(&tswv_container_bytes).unwrap();
//!     assert_eq!(type_id, TestVersionedContainer::ARCHIVE_TYPE_ID);
//!     assert_eq!(version_id, container.get_entry_version_id());
//!
//!     // You can now more confidently access the data using zero-copy rkyv primitives
//!     let twsv_ref: &ArchivedTestVersionedContainer<'_> =
//!         TestVersionedContainer::access_from_tagged_bytes(&tswv_container_bytes).unwrap();
//!     match twsv_ref {
//!         ArchivedTestVersionedContainer::V1(v1_ref) => {
//!             assert_eq!(v1_ref.a, 1);
//!             assert_eq!(v1_ref.b, 2);
//!             assert_eq!(v1_ref.c, "YEET");
//!         }
//!         _ => panic!("Expected V1"),
//!     }
//! }
//! ```
//!
//! # Functions
//! - [to_tagged_bytes]: Serializes a versioned container to a tagged byte stream, embedding the
//!   type ID and the version ID of the variant along with the data.
//! - [access_from_tagged_bytes]: Deserializes a versioned container from a tagged byte stream and
//!   validates type and version IDs.
//!
//! # Traits
//! - [VersionedContainer]: A trait that is automatically implemented on a versioned container using
//!   the
//! `#[derive(VersionedArchiveContainer)]` attribute.
//!
//! # Error Types
//! - [UnexpectedTypeError]: Error indicating a mismatch between expected and actual type IDs.
//! - [UnsupportedVersionError]: Error indicating an unsupported version ID.
//!
//! # Internal Container Structures
//! These structures are used internally to handle versioned data and are generally not used
//! directly.
//! - [TaggedVersionedContainer]: A container that includes type and version IDs along with the
//!   data.
//! - [TaggedVersionedContainerHeaderOnly]: A container that includes only type and version IDs.
use core::{error::Error, fmt};
use rkyv::api::high::HighSerializer;
use rkyv::ser::allocator::ArenaHandle;
use rkyv::util::AlignedVec;
use rkyv::with::Inline;
use rkyv::{Archive, Serialize};

// Re-export the derive macro
pub use const_crc32;
pub use rkyv_versioned_derive::VersionedArchiveContainer;

/// An error indicating that the passed type ID does not match the type ID of the passed
/// [VersionedContainer]
#[derive(Debug)]
pub struct UnexpectedTypeError(pub u32, pub u32);
impl Error for UnexpectedTypeError {}
impl fmt::Display for UnexpectedTypeError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Expected type_id {}, got {}", self.0, self.1)
    }
}

/// An error indicating that the passed version ID is not supported by the passed
/// [VersionedContainer]
///
/// This typically implies that you are deserializing a newer version of a container than the one
/// generated by the current code.
#[derive(Debug)]
pub struct UnsupportedVersionError(pub u32);
impl Error for UnsupportedVersionError {}
impl fmt::Display for UnsupportedVersionError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Unsupported version {}", self.0)
    }
}

/// A container that holds a versioned item along with its type and version IDs.
///
/// This is the structure that is the result of serializing a versioned container. We use a tuple
/// struct to allow us to "peek" at the header without deserializing the entire item, exploiting the
/// fact that `rkyv` tuples are laid out in a predictable order.
///
/// This generally shouldn't need to be used directly, but is exposed for convenience.
#[derive(Debug, Clone, Archive, Serialize)]
pub struct TaggedVersionedContainer<'a, T: Archive>(
    /// The type ID of the item.
    pub u32,
    /// The version ID of the item
    pub u32,
    /// A reference to the item
    #[rkyv(with = Inline)]
    pub &'a T,
);

/// A container that holds only the type and version IDs of a versioned item.
///
/// This exists mostly just as a convenience to access the first two elements of a
/// [TaggedVersionedContainer] without deserializing the entire item.
///
/// This generally shouldn't need to be used directly, but is exposed for convenience.
#[derive(Debug, Clone, Archive, Serialize)]
pub struct TaggedVersionedContainerHeaderOnly(
    /// * `0` - The type ID of the item.
    pub u32,
    /// * `1` - The version ID of the item.
    pub u32,
);

/// Serializes a versioned container into a tagged byte array to be deserialized from
/// [access_from_tagged_bytes].
///
/// This can also be generated by calling [VersionedContainer::to_tagged_bytes] directly.
///
/// # Arguments
///
/// * `item` - A reference to the item to be serialized.
///
/// # Returns
///
/// A `Result` containing either the serialized byte array or an error if serialization fails.
pub fn to_tagged_bytes<T: VersionedContainer>(item: &T) -> Result<AlignedVec, rkyv::rancor::Error>
where
    T: for<'a> Serialize<HighSerializer<AlignedVec, ArenaHandle<'a>, rkyv::rancor::Error>>,
{
    let container = TaggedVersionedContainer(T::ARCHIVE_TYPE_ID, item.get_entry_version_id(), item);
    rkyv::to_bytes(&container)
}

/// Deserializes a versioned container from a tagged byte array generated by [to_tagged_bytes]. or
/// [VersionedContainer::to_tagged_bytes].
///
/// # Arguments
///
/// * `buf` - A reference to the byte array containing the tagged serialized data.
///
/// # Returns
///
/// A `Result` containing either a reference to the deserialized item or an error if deserialization
/// fails.
pub fn access_from_tagged_bytes<'a, T: VersionedContainer + 'a>(
    buf: &'a [u8],
) -> Result<&'a T::Archived, rkyv::rancor::Error>
where
    T::Archived: rkyv::Portable
        + for<'b> rkyv::bytecheck::CheckBytes<rkyv::api::high::HighValidator<'b, rkyv::rancor::Error>>,
{
    let (type_id, version_id) = T::get_type_and_version_from_tagged_bytes(buf)?;

    // Ensure the type header is correct
    if type_id != T::ARCHIVE_TYPE_ID {
        rkyv::rancor::fail!(UnexpectedTypeError(T::ARCHIVE_TYPE_ID, type_id));
    }

    // Ensure the version header is valid
    if T::is_valid_version_id(version_id) {
        let archived =
            rkyv::access::<ArchivedTaggedVersionedContainer<T>, rkyv::rancor::Error>(&buf)?;
        Ok(&archived.2)
    } else {
        rkyv::rancor::fail!(UnsupportedVersionError(version_id))
    }
}

/// A trait that is automatically implemented on a versioned container using the
/// `#[derive(VersionedArchiveContainer)]` attribute.
///
/// This trait extends the `Archive` trait and provides additional methods
/// for handling versioned data. Manual implementors of this trait must provide
/// methods for validating version IDs, retrieving the version ID of an entry,
/// and converting between tagged bytes and archived data.
///
/// # Example
/// TODO
pub trait VersionedContainer: Archive {
    /// A constant representing the type ID of the archived data. When generated by
    /// the derive macro, this is a CRC32 hash of the type name.
    const ARCHIVE_TYPE_ID: u32;

    /// Checks if the provided version ID is valid.
    fn is_valid_version_id(version: u32) -> bool;

    /// Retrieves the version ID of the current variant
    fn get_entry_version_id(&self) -> u32;

    /// Extracts the type and version ID from the provided tagged bytes
    fn get_type_and_version_from_tagged_bytes(
        buf: &[u8],
    ) -> Result<(u32, u32), rkyv::rancor::Error>;

    /// Retrieves a reference to the archived data from the provided tagged bytes.
    fn access_from_tagged_bytes(buf: &[u8]) -> Result<&Self::Archived, rkyv::rancor::Error>;

    /// Serializes the current item to a tagged byte stream, complete with the ARCHIVE_TYPE_ID and
    /// version_id of the current item.
    fn to_tagged_bytes(item: &Self) -> Result<AlignedVec, rkyv::rancor::Error>
    where
        Self: for<'a> Serialize<HighSerializer<AlignedVec, ArenaHandle<'a>, rkyv::rancor::Error>>;
}

#[cfg(test)]
mod tests {
    use super::*;
    use rkyv::Deserialize;

    #[derive(Debug, PartialEq, Archive, Serialize, Deserialize)]
    #[rkyv(compare(PartialEq))]
    struct TestStructV1 {
        pub a: u32,
        pub b: u32,
        pub c: String,
    }

    #[derive(Debug, PartialEq, Archive, Serialize, Deserialize)]
    #[rkyv(compare(PartialEq))]
    struct TestStructV2 {
        pub a: u64,
        pub b: u64,
        pub c: u64,
        pub d: String,
    }

    #[derive(Debug, PartialEq, Archive, Serialize, Deserialize, VersionedArchiveContainer)]
    #[rkyv(compare(PartialEq))]
    enum TestContainer<'a> {
        V1(#[rkyv(with=Inline)] &'a TestStructV1),
        V2(#[rkyv(with=Inline)] &'a TestStructV2),
    }

    #[test]
    fn test_versioned_container() {
        let v1 = TestStructV1 {
            a: 1,
            b: 2,
            c: "YEET".to_owned(),
        };
        let v1_container = TestContainer::V1(&v1);

        let tswv_container_bytes: AlignedVec =
            TestContainer::to_tagged_bytes(&v1_container).unwrap();
        assert_eq!(
            TestContainer::get_type_and_version_from_tagged_bytes(&tswv_container_bytes).unwrap(),
            (
                TestContainer::ARCHIVE_TYPE_ID,
                v1_container.get_entry_version_id()
            )
        );

        // Validate that the trait impl and the bare impl both give the same result
        let twsv_ref = TestContainer::access_from_tagged_bytes(&tswv_container_bytes).unwrap();

        match twsv_ref {
            ArchivedTestContainer::V1(v1_ref) => {
                assert_eq!(v1_ref.a, 1);
                assert_eq!(v1_ref.b, 2);
                assert_eq!(v1_ref.c, "YEET");
            }
            _ => panic!("Expected V1"),
        }

        let v2 = TestStructV2 {
            a: 100,
            b: 200,
            c: 300,
            d: "SKEET".to_owned(),
        };
        let v2_container = TestContainer::V2(&v2);
        let tswv_container_bytes: AlignedVec =
            TestContainer::to_tagged_bytes(&v2_container).unwrap();
        assert_eq!(
            TestContainer::get_type_and_version_from_tagged_bytes(&tswv_container_bytes).unwrap(),
            (
                TestContainer::ARCHIVE_TYPE_ID,
                v2_container.get_entry_version_id()
            )
        );
        let twsv_ref = TestContainer::access_from_tagged_bytes(&tswv_container_bytes).unwrap();

        match twsv_ref {
            ArchivedTestContainer::V2(v2_ref) => {
                assert_eq!(v2_ref.a, 100);
                assert_eq!(v2_ref.b, 200);
                assert_eq!(v2_ref.c, 300);
                assert_eq!(v2_ref.d, "SKEET");
            }
            _ => panic!("Expected V2"),
        }

        // Generate invalid type id
        const EXPECTED_TYPE_ID: u32 = const_crc32::crc32("TestContainer".as_bytes());
        const MUNGED_TYPE_ID: u32 = 0x01010101;

        let mut invalid_type_bytes = tswv_container_bytes.clone();
        invalid_type_bytes[0] = 0x01;
        invalid_type_bytes[1] = 0x01;
        invalid_type_bytes[2] = 0x01;
        invalid_type_bytes[3] = 0x01;

        let invalid_type_result = TestContainer::access_from_tagged_bytes(&invalid_type_bytes);
        assert!(invalid_type_result.is_err());
        assert_eq!(
            invalid_type_result.err().unwrap().to_string(),
            format!(
                "Expected type_id {}, got {}",
                EXPECTED_TYPE_ID, MUNGED_TYPE_ID
            )
        );

        // Generate invalid version id
        let mut invalid_ver_bytes = tswv_container_bytes.clone();
        invalid_ver_bytes[4] = 9;

        let invalid_ver_result = TestContainer::access_from_tagged_bytes(&invalid_ver_bytes);
        assert!(invalid_ver_result.is_err());
        assert_eq!(
            invalid_ver_result.err().unwrap().to_string(),
            "Unsupported version 9"
        );
    }
}
