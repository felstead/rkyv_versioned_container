//! This crate provides functionality for supporting versioned serialization and
//! deserialization of `rkyv` Archives, allowing for backwards and (limited) forwards
//! compatibility between different versions of your code.  This is implemented through using
//! the `#[derive(VersionedArchiveContainer)]` macro as generated by the sister
//! [rkyv_versioned_derive] crate.
//!
//! # Usage
//! To provide backwards and forwards compatibility between structures formatted by `rkyv`, we
//! follow these steps:
//! - We should provide implementations of all "known" versions of an `rkyv` structure in our
//!   code (see `TestStructV1` and `TestStructV2` in the example below)
//! - We wrap these versions in an enum describing all of the different versions, and use the
//!   `#[derive(VersionedArchiveContainer)]` macro on that enum in addition to your usual
//!   `#[derive(Archive, Serialize, Deserialize)]` definitions for an `rkyv` type, see
//!   `TestVersionedContainer` in the example below.
//!
//! However, there are some important rules to abide by:
//! - **The layout/structure of the `rkyv` implementations MUST NOT CHANGE between versions of
//!   the code** - if you make changes, it is important to declare a new type and add it to our
//!   versioned container. This is because we will try to deserialize/access the data using the
//!   implementation in the current code, so if we serialize `TestStructV1` with one layout and
//!   then change it later, it may not be able to be read correctly.  Instead, try declaring
//!   `TestStructV2` and add it to our versioned container.
//! - **The versioned container's enum order MUST NOT CHANGE** - the IDs of each variant are
//!   based on their order, so it is important to keep this consistent and **only add new
//!   variants to the end of the struct**.
//!
//!
//! # Example
//! ```rust
//! use rkyv::{Archive, Serialize, Deserialize};
//! use rkyv::util::AlignedVec;
//! use rkyv::with::InlineAsBox;
//! use rkyv_versioned::*;
//!
//! #[derive(Debug, Archive, Serialize, Deserialize)]
//! struct TestStructV1 {
//!     pub a: u32,
//!     pub b: u32,
//!     pub c: String,
//! }
//!
//! #[derive(Debug, Archive, Serialize, Deserialize)]
//! struct TestStructV2 {
//!     pub a: u64,
//!     pub b: u64,
//!     pub c: u64,
//!     pub d: String,
//! }
//!
//! #[derive(Debug, Archive, Serialize, Deserialize, VersionedArchiveContainer)]
//! enum TestVersionedContainer<'a> {
//!     V1(#[rkyv(with=InlineAsBox)] &'a TestStructV1),
//!     V2(#[rkyv(with=InlineAsBox)] &'a TestStructV2),
//! }
//!
//! fn main() {
//!     // Serialize a v1 into a versioned container byte stream
//!     let v1 = TestStructV1 {
//!         a: 1,
//!         b: 2,
//!         c: "YEEEEEEEEEEET".to_owned(),
//!     };
//!
//!     // Create our versioned container to store our v1 data
//!     let container = TestVersionedContainer::V1(&v1);
//!
//!     // This byte stream contains extra metadata allowing you to identify the type and version
//!     // before attempting to access it
//!     let tswv_container_bytes: AlignedVec = to_tagged_bytes(&container).unwrap();
//!
//!     // Imagine now that you're reading this byte stream from a file or network - it is
//!     // _probably_ a TestContainer::V1, but you can't be sure, it _could_ be a
//!     // TestContainer::V2 (which would be fine) or, if we're older version of the code
//!     // against newer data, a TestContainer::V3.  Or maybe it's not even a TestContainer at
//!     // all. With the tagged container, we can validate beforehand, or have logic to handle
//!     // different structures or versions.
//!     let (type_id, version_id) =
//!         get_type_and_version_from_tagged_bytes(&tswv_container_bytes).unwrap();
//!     assert_eq!(type_id, TestVersionedContainer::ARCHIVE_TYPE_ID);
//!     assert_eq!(version_id, container.get_entry_version_id());
//!
//!     // You can now more confidently access the data using zero-copy rkyv primitives.
//!     // Alternatively, you can implicitly use the `RkyvVersionedError` type to handle errors
//!     // programmatically.
//!     match access_from_tagged_bytes::<TestVersionedContainer>(&tswv_container_bytes) {
//!         Ok(ArchivedTestVersionedContainer::V1(v1_ref)) => {
//!             assert_eq!(v1_ref.a, 1);
//!             assert_eq!(v1_ref.b, 2);
//!             assert_eq!(v1_ref.c, "YEEEEEEEEEEET");
//!         }
//!         Ok(_) => panic!("Expected V1"),
//!         Err(RkyvVersionedError::BufferTooSmallError) => panic!("Buffer too small!"),
//!         Err(RkyvVersionedError::UnexpectedTypeError(expected, found)) => {
//!             panic!("Expected type {} but got {}", expected, found)
//!         }
//!         Err(RkyvVersionedError::UnsupportedVersionError(version)) => {
//!             panic!("Found unsupported version {}", version)
//!         }
//!         Err(RkyvVersionedError::RkyvError(rkyv_error)) => panic!("Rkyv error: {}", rkyv_error),
//!     };
//! }
//! ```
//!
//! # Functions
//! - [to_tagged_bytes]: Serializes a versioned container to a tagged byte stream, embedding
//!   the type ID and the version ID of the variant along with the data.
//! - [access_from_tagged_bytes]: Deserializes a versioned container from a tagged byte stream
//!   and validates type and version IDs.
//!
//! # Traits
//! - [VersionedContainer]: A trait that is automatically implemented on a versioned container
//!   using the
//! `#[derive(VersionedArchiveContainer)]` attribute.
//!
//! # Error Types
//! Given that introspection of the deserialization errors are more useful in this context
//! (e.g. it is useful to know whether a `version_id` or `type_id` was wrong), we used a
//! type-composed error [RkyvVersionedError] type rather than just `rancor::Error`.  This
//! departs a little from the conventions of `rkyv` but is a little more practical in this
//! scenario where failures might need to be dealt with programmatically.
//!
//! # Internal Container Structures
//! These structures are used internally to handle versioned data and are generally not used
//! directly.
//! - [TaggedVersionedStruct]: A container that includes type and version IDs along with the
//!   data.

use core::{error::Error, fmt};
use rkyv::api::high::HighSerializer;
use rkyv::ser::allocator::ArenaHandle;
use rkyv::util::AlignedVec;
use rkyv::with::InlineAsBox;
use rkyv::{Archive, Serialize};

// Re-export the derive macro
pub use const_crc32;
pub use rkyv_versioned_derive::VersionedArchiveContainer;

#[derive(Debug)]
pub enum RkyvVersionedError {
    BufferTooSmallError,
    UnexpectedTypeError(u32, u32),
    UnsupportedVersionError(u32),
    RkyvError(rkyv::rancor::Error),
}
impl Error for RkyvVersionedError {}
impl fmt::Display for RkyvVersionedError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            RkyvVersionedError::BufferTooSmallError => {
                write!(f, "Buffer was less than the size of the header")
            }
            RkyvVersionedError::UnexpectedTypeError(expected, got) => {
                write!(f, "Expected type_id {}, got {}", expected, got)
            }
            RkyvVersionedError::UnsupportedVersionError(version) => {
                write!(f, "Unsupported version {}", version)
            }
            RkyvVersionedError::RkyvError(e) => write!(f, "{}", e),
        }
    }
}

/// A container that holds a versioned item along with its type and version IDs.
///
/// This is the structure that is the result of serializing a versioned container. We
/// deserialize this with the `T` type set as `()` to allow us to "peek" at the header fields
/// without deserializing the entire item.
#[derive(Debug, Clone, Archive, Serialize)]
pub struct TaggedVersionedStruct<'a, T: Archive> {
    pub type_id: u32,
    pub version_id: u32,
    #[rkyv(with = InlineAsBox)]
    pub inner: &'a T,
}

/// Serializes a versioned container into a tagged byte array to be deserialized from
/// [access_from_tagged_bytes].  This is analogous to `rkyv::to_bytes`, but only for
/// [VersionedContainer] derived enums.
///
/// # Arguments
///
/// * `item` - A reference to the item to be serialized.
///
/// # Returns
///
/// A `Result` containing either the serialized byte array or an error if serialization fails.
pub fn to_tagged_bytes<T: VersionedContainer>(
    item: &T,
) -> Result<AlignedVec, RkyvVersionedError>
where
    T: for<'a> Serialize<HighSerializer<AlignedVec, ArenaHandle<'a>, rkyv::rancor::Error>>,
{
    let container = TaggedVersionedStruct {
        type_id: T::ARCHIVE_TYPE_ID,
        version_id: item.get_entry_version_id(),
        inner: item,
    };
    rkyv::to_bytes(&container).map_err(|e| RkyvVersionedError::RkyvError(e))
}

/// Serializes a versioned container into the provided writer, to be deserialized from
/// [access_from_tagged_bytes].  This is analogous to `rkyv::to_bytes_in`, but only for
/// [VersionedContainer] derived enums.
///
/// # Arguments
///
/// * `item` - A reference to the item to be serialized.
/// * `writer` - The writer to write the serialized data to.
///
/// # Returns
///
/// A `Result` containing either the serialized byte array or an error if serialization fails.
pub fn to_tagged_bytes_in<T: VersionedContainer, W>(
    item: &T,
    writer: W,
) -> Result<W, RkyvVersionedError>
where
    T: for<'a> Serialize<HighSerializer<W, ArenaHandle<'a>, rkyv::rancor::Error>>,
    W: rkyv::ser::Writer<rkyv::rancor::Error>,
{
    let container = TaggedVersionedStruct {
        type_id: T::ARCHIVE_TYPE_ID,
        version_id: item.get_entry_version_id(),
        inner: item,
    };
    rkyv::api::high::to_bytes_in::<_, rkyv::rancor::Error>(&container, writer)
        .map_err(|e| RkyvVersionedError::RkyvError(e))
}

/// "Peeks" at the type_id and version_id inside a tagged byte array generated by
/// [to_tagged_bytes] and returns them.
///
/// This is useful in the context of pre-validating the type and version of a tagged byte array
/// before deserializing.
///
/// # Arguments
///
/// * `buf` - A reference to the byte array containing the tagged serialized data.
///
/// # Returns
///
/// A `Result` containing the `type_id` and `version_id` of the item, or [RkyvVersionedError]
/// with the `BufferTooSmall` variant if the buffer is undersized.
pub fn get_type_and_version_from_tagged_bytes(
    buf: &[u8],
) -> Result<(u32, u32), RkyvVersionedError> {
    const MIN_SIZE: usize = core::mem::size_of::<ArchivedTaggedVersionedStruct<()>>();

    if buf.len() < MIN_SIZE {
        return Err(RkyvVersionedError::BufferTooSmallError);
    }

    let header = rkyv::access::<ArchivedTaggedVersionedStruct<()>, rkyv::rancor::Error>(&buf)
        .map_err(|e| RkyvVersionedError::RkyvError(e))?;

    Ok((header.type_id.into(), header.version_id.into()))
}

/// Zero-copy deserializes a versioned container from a tagged byte array generated by
/// [to_tagged_bytes].
///
/// # Arguments
///
/// * `buf` - A reference to the byte array containing the tagged serialized data.
///
/// # Returns
///
/// A `Result` containing either a reference to the deserialized item or an error if
/// deserialization fails.
pub fn access_from_tagged_bytes<'a, T: VersionedContainer + 'a>(
    buf: &'a [u8],
) -> Result<&'a T::Archived, RkyvVersionedError>
where
    T::Archived: rkyv::Portable
        + for<'b> rkyv::bytecheck::CheckBytes<
            rkyv::api::high::HighValidator<'b, rkyv::rancor::Error>,
        >,
{
    let (type_id, version_id) = get_type_and_version_from_tagged_bytes(buf)?;

    // Ensure the type header is correct
    if type_id != T::ARCHIVE_TYPE_ID {
        return Err(RkyvVersionedError::UnexpectedTypeError(
            T::ARCHIVE_TYPE_ID,
            type_id,
        ));
    }

    // Ensure the version header is valid
    if T::is_valid_version_id(version_id) {
        let archived =
            rkyv::access::<ArchivedTaggedVersionedStruct<T>, rkyv::rancor::Error>(&buf)
                .map_err(|e| RkyvVersionedError::RkyvError(e))?;
        Ok(&archived.inner)
    } else {
        Err(RkyvVersionedError::UnsupportedVersionError(version_id))
    }
}

/// Unsafely zero-copy deserializes a versioned container from a tagged byte array generated by
/// [to_tagged_bytes].
///
/// # Arguments
///
/// * `buf` - A reference to the byte array containing the tagged serialized data.
///
/// # Returns
///
/// A reference to the inner archived type
///
/// # SAFETY
/// This function is unsafe because it does not perform any validation on the type or version
/// ID or the underlying bytes. It is only recommended to use this when you have either already
/// validated the buffer, or are just passing the data around internally.
pub unsafe fn access_from_tagged_bytes_unchecked<'a, T: VersionedContainer + 'a>(
    buf: &'a [u8],
) -> &'a T::Archived {
    let archived = rkyv::access_unchecked::<ArchivedTaggedVersionedStruct<T>>(&buf);
    &archived.inner
}

/// A trait that is automatically implemented on a versioned container using the
/// `#[derive(VersionedArchiveContainer)]` attribute.
///
/// This trait extends the `Archive` trait and provides additional methods
/// for handling versioned data. Manual implementors of this trait must provide
/// methods for validating version IDs, retrieving the version ID of an entry,
/// and converting between tagged bytes and archived data.
///
/// # Example
/// TODO
pub trait VersionedContainer: Archive {
    /// A constant representing the type ID of the archived data. When generated by
    /// the derive macro, this is a CRC32 hash of the type name.
    const ARCHIVE_TYPE_ID: u32;

    /// Checks if the provided version ID is valid.
    fn is_valid_version_id(version: u32) -> bool;

    /// Retrieves the version ID of the current variant
    fn get_entry_version_id(&self) -> u32;
}

#[cfg(test)]
mod tests {
    use core::panic;

    use super::*;
    use rkyv::Deserialize;

    #[derive(Debug, PartialEq, Archive, Serialize, Deserialize)]
    #[rkyv(compare(PartialEq))]
    struct TestStructV1 {
        pub a: u32,
        pub b: u32,
        pub c: String,
    }

    #[derive(Debug, PartialEq, Archive, Serialize, Deserialize)]
    #[rkyv(compare(PartialEq))]
    struct TestStructV2 {
        pub a: u64,
        pub b: u64,
        pub c: u64,
        pub d: String,
    }

    #[derive(Debug, PartialEq, Archive, Serialize, Deserialize, VersionedArchiveContainer)]
    #[rkyv(compare(PartialEq))]
    enum TestContainer<'a> {
        V1(#[rkyv(with=InlineAsBox)] &'a TestStructV1),
        V2(#[rkyv(with=InlineAsBox)] &'a TestStructV2),
    }

    #[test]
    fn test_versioned_container() {
        // Longer strings will be serialized out-of-line in the data, so it is important to
        // test that scenario
        let v1 = TestStructV1 {
            a: 1,
            b: 2,
            c: "YEEEEEEEEEEEEEEEEEEEET".to_owned(),
        };
        let v1_container = TestContainer::V1(&v1);

        let tswv_container_bytes: AlignedVec =
            to_tagged_bytes::<TestContainer>(&v1_container).unwrap();
        assert_eq!(
            get_type_and_version_from_tagged_bytes(&tswv_container_bytes).unwrap(),
            (
                TestContainer::ARCHIVE_TYPE_ID,
                v1_container.get_entry_version_id()
            )
        );

        // Validate that the trait impl and the bare impl both give the same result
        let twsv_ref =
            access_from_tagged_bytes::<TestContainer>(&tswv_container_bytes).unwrap();

        match twsv_ref {
            ArchivedTestContainer::V1(v1_ref) => {
                assert_eq!(v1_ref.a, 1);
                assert_eq!(v1_ref.b, 2);
                assert_eq!(v1_ref.c, "YEEEEEEEEEEEEEEEEEEEET");
            }
            _ => panic!("Expected V1"),
        }

        // Validate unchecked version is the same
        let twsv_ref_unchecked = unsafe { access_from_tagged_bytes_unchecked::<TestContainer>(&tswv_container_bytes) };
        match twsv_ref_unchecked {
            ArchivedTestContainer::V1(v1_ref) => {
                assert_eq!(v1_ref.a, 1);
                assert_eq!(v1_ref.b, 2);
                assert_eq!(v1_ref.c, "YEEEEEEEEEEEEEEEEEEEET");
            }
            _ => panic!("Expected V1"),
        }

        let v2 = TestStructV2 {
            a: 100,
            b: 200,
            c: 300,
            d: "SKEET".to_owned(),
        };
        let v2_container = TestContainer::V2(&v2);
        let tswv_container_bytes: AlignedVec = to_tagged_bytes(&v2_container).unwrap();
        assert_eq!(
            get_type_and_version_from_tagged_bytes(&tswv_container_bytes).unwrap(),
            (
                TestContainer::ARCHIVE_TYPE_ID,
                v2_container.get_entry_version_id()
            )
        );
        let twsv_ref =
            access_from_tagged_bytes::<TestContainer>(&tswv_container_bytes).unwrap();

        match twsv_ref {
            ArchivedTestContainer::V2(v2_ref) => {
                assert_eq!(v2_ref.a, 100);
                assert_eq!(v2_ref.b, 200);
                assert_eq!(v2_ref.c, 300);
                assert_eq!(v2_ref.d, "SKEET");
            }
            _ => panic!("Expected V2"),
        }

        const EXPECTED_TYPE_ID: u32 = const_crc32::crc32("TestContainer".as_bytes());
        const MUNGED_TYPE_ID: u32 = 0x01010101;

        // Generate invalid type id
        let invalid_type_struct = TaggedVersionedStruct::<TestContainer> {
            type_id: MUNGED_TYPE_ID,
            version_id: 0,
            inner: &v1_container,
        };
        let invalid_type_bytes =
            rkyv::to_bytes::<rkyv::rancor::Error>(&invalid_type_struct).unwrap();

        match access_from_tagged_bytes::<TestContainer>(&invalid_type_bytes) {
            Err(RkyvVersionedError::UnexpectedTypeError(expected, got)) => {
                assert_eq!(expected, EXPECTED_TYPE_ID);
                assert_eq!(got, MUNGED_TYPE_ID);
            }
            _ => panic!("Expected RkyvVersionedError::UnexpectedTypeError"),
        };

        // Generate invalid version id
        const MUNGED_VERSION_ID: u32 = 0x01010101;
        let invalid_version_struct = TaggedVersionedStruct::<TestContainer> {
            type_id: EXPECTED_TYPE_ID,
            version_id: MUNGED_VERSION_ID,
            inner: &v1_container,
        };

        let invalid_version_bytes =
            rkyv::to_bytes::<rkyv::rancor::Error>(&invalid_version_struct).unwrap();

        match access_from_tagged_bytes::<TestContainer>(&invalid_version_bytes) {
            Err(RkyvVersionedError::UnsupportedVersionError(version)) => {
                assert_eq!(version, MUNGED_VERSION_ID);
            }
            _ => panic!("Expected RkyvVersionedError::UnsupportedVersionError"),
        };
    }
}
